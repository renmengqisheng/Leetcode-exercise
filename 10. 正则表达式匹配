给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。

示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。

示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。

示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。

示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

思路一：（直接对string进行操作，需要考虑是否越界）

分几种情况讨论：

1、当p为空，s也为空，返回true；

2、当p为空，s不为空，返回false；

3、当p不为空，而s为空时，又可以分成几种情况：

1）p长度为1，无法匹配，返回false；

2）p长度为2，且第2个元素为*，返回true；

3）p长度大于2，且第2个元素为*，跳过p的前2位（即*匹配0个p[0]）再和s匹配，递归求解；

4）其他情况都返回false；

4、当p和s都不为空时，又可以分成几种情况：

1）p和s的第一个元素相等，或者p的第一个元素为'.'，同时s的第一个元素不等于0：

a、当p长度为1时，如果s长度也为1，返回true；否则，返回false；

b、当p长度大于1，且p的第2个元素不等于*时，将p和s的下一位继续匹配；

c、当p长度大于1，且第2个元素等于*时，此时p的第一个元素可能有0个、1个和1个以上这三种情况，其中第一种情况相当于去掉p的前两位，从p的第3个元素开始和s进行匹配（此时应保证p大于2，否则直接返回false），后面两种情况可以合并成同1个情况（即s从下一位开始继续和p匹配）；

2）p和s的第一个元素不相等，同时p的第一个元素不为'.'：

a、当p长度大于1，且p的第2个元素为*，从p的第3个元素（即*取0）开始和s匹配（此时应保证p大于2，否则直接返回false）；

b、其他情况无法匹配，返回false。

